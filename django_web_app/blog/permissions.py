# Мы импортируем разрешения сверху,
from rest_framework import permissions


# Мы хотим, чтобы только автор конкретного сообщения
# в блоге мог редактировать или удалять его; в противном
# случае сообщение в блоге должно быть доступно только для чтения.

# Чтобы создать собственное пользовательское разрешение,
# мы переопределим
# метод has_object_permission. В частности, мы хотим разрешить
# только чтение для всех запросов, но для любых
# запросов на запись, таких как редактирование или удаление,
# автор должен быть таким же, как и текущий вошедший
# пользователь.

class BasePermission(object):
    """
    Базовый класс, от которого должны наследовать все классы разрешений.
    """

    def has_permission(self,request,view):
        """
        Верните "True`, если разрешение предоставлено,
        и "False" в противном случае.
        """

        return True

    def has_object_permission(self,request,view,obj):
        """
        Верните "True`, если разрешение предоставлено,
        и "False" в противном случае.
        """


# Чтобы создать собственное пользовательское разрешение,
# мы переопределим
# метод has_object_permission. В частности, мы хотим разрешить
# только чтение для всех запросов, но для любых
# запросов на запись, таких как редактирование или удаление,
# автор должен быть таким же, как и текущий вошедший
# пользователь.

# Cоздаем пользовательский класс IsAuthorOrReadOnly,
# который расширяет BasePermission .
# Если запрос
# содержит HTTP-глаголы , включенные в SAFE_METHODS –кортеж ,
# содержащий GET, OPTIONS и
# HEAD –тогда это запрос только для чтения,
# и разрешение предоставляется.
# В противном случае запрос предназначен для какой-то записи, что означает обновление
# ресурса API, так что либо создавайте, удаляйте, либо редактируйте функциональность. В этом случае мы проверяем
# , соответствует ли автор рассматриваемого объекта, которым является наш пост в блоге obj.author, пользователю
# , делающему запрос request.user .
class IsAuthorOrReadOnly(permissions.BasePermission):
    # Затем мы переопределяем has_object_permission
    def has_object_permission(self, request, view, obj):
        # Если запрос
        # содержит HTTP-глаголы , включенные в SAFE_METHODS –кортеж ,
        # содержащий GET, OPTIONS и
        # HEAD –тогда это запрос только для чтения,
        # и разрешение предоставляется.
    # Разрешения только для чтения разрешены для любого запроса
        if request.method in permissions.SAFE_METHODS:
            return True
        # В противном случае запрос предназначен для какой-то записи, что означает обновление
        # ресурса API, так что либо создавайте, удаляйте, либо редактируйте функциональность. В этом случае мы проверяем
        # , соответствует ли автор рассматриваемого объекта, которым является наш пост в блоге obj.author, пользователю
        # , делающему запрос request.user .
    # Права на запись разрешены только автору сообщения
        return obj.author==request.user


